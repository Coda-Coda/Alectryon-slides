<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Untangling mechanized proofs</title><meta charset="UTF-8"></meta><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="talk.css" media="screen,projection"></link><link rel="stylesheet" href="alectryon.css" media="screen,projection"></link><link rel="stylesheet" href="tango_subtle.css" media="screen,projection"></link><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        showProcessingMessages: false,
        messageStyle: "none",
        TeX : { extensions : ['color.js'] }
      });
    </script></head><body class="impress-not-supported"><div id="impress-help"></div><div id="impress" data-transition-duration="0.01"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><div class="titlepage"><p>.</p></div><h1 id="untangling-mechanized-proofs">Untangling mechanized proofs</h1><h2 id="clement-pit-claudel">Cl&#xE9;ment Pit-Claudel</h2><h3 id="sle-2020">SLE 2020</h3><div class="notes"><p>.</p></div></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="2600" data-y="0" data-z="0"><h1 id="a-tour-of-alectryon">A tour of Alectryon</h1><div class="notes"><p>Back in undergrad I taught in high school for a few months. There was a proof I liked to show my students, because it surprised most of them.</p></div></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="5200" data-y="0" data-z="0"><script type="text/javascript">
  MathJax = {
      options: {
          skipHtmlTags: [
              'script', 'noscript', 'style', 'textarea',
              'annotation', 'annotation-xml'
          ]
      },
      startup: {
          pageReady: function () {
              mathjax_setup();
              return MathJax.startup.defaultPageReady();
          }
      }
  };
</script>

<script type="text/javascript" id="MathJax-script" async
   src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script><div class="xxxxl"><div class="math-block ">$$\begin{align}\frac{a}{c} + \frac{b}{d} \not= \frac{a + b}{c + d}\end{align}$$</div></div><div class="notes"><p>This was the setup: every student knows that you can't sum fractions element-wise.
What many students don't know is that you <em>can</em>, actually, as long as long you're just trying to prove an inequality.</p></div></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="7800" data-y="0" data-z="0"><div class="xxxxl"><div class="math-block ">$$\begin{align}\frac{a}{c} + \frac{b}{d} \ge \frac{a + b}{c + d}\end{align}$$</div></div><div class="notes"><p>My main line of research is doing proofs with Coq, so let me share a Coq proof of this inequality.</p></div></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="10400" data-y="0" data-z="0"><div style="display: none">
    \(\newcommand{\ccQ}{\mathbb{Q}}\)
    \(\newcommand{\ccNat}{\mathbb{N}}\)
    \(\newcommand{\ccSucc}[1]{\mathrm{S}\:#1}\)
    \(\newcommand{\ccFrac}[2]{\frac{#1}{#2}}\)
    \(\newcommand{\ccPow}[2]{{#1}^{#2}}\)
    \(\newcommand{\ccNot}[1]{{\lnot #1}}\)
    \(\newcommand{\ccEvar}[1]{\textit{\texttt{#1}}}\)
    \(\newcommand{\ccForall}[2]{\forall \: #1. \; #2}\)
    \(\newcommand{\ccNsum}[3]{\sum_{#1 = 0}^{#2} #3}\)
</div><div class="proof-overlay"><pre class="highlight code coq"><span class="kn">Lemma</span> <span class="nf">Qle_pairwise</span> <span class="o">:</span> <span class="kr">&#x2200;</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="o">,</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&#x2227;</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">&#x2227;</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">c</span> <span class="o">&#x2227;</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">d</span> <span class="o">&#x2192;</span>
  <span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="o">)/(</span><span class="n">b</span> <span class="o">+</span> <span class="n">d</span><span class="o">)</span> <span class="o">&#x2264;</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="o">/</span><span class="n">d</span><span class="o">.</span>
<span class="kn">Proof with</span> <span class="n">Qeauto</span><span class="o">.</span>
  <span class="nb">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">H</span><span class="o">.</span>
  <span class="nb">field_simplify</span><span class="o">...</span>
  <span class="nb">rewrite</span> <span class="o">&lt;-</span> <span class="o">(</span><span class="n">Qmult_le_l</span> <span class="o">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">d</span><span class="o">)),</span> <span class="n">Qmult_div_r</span><span class="o">,</span> <span class="n">Qmult_Qdiv_fact</span><span class="o">...</span>
  <span class="nb">rewrite</span> <span class="o">&lt;-</span> <span class="o">(</span><span class="n">Qmult_le_l</span> <span class="o">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">d</span><span class="o">)),</span> <span class="n">Qmult_div_r</span><span class="o">...</span>
  <span class="nb">field_simplify</span><span class="o">.</span>
  <span class="nb">rewrite</span> <span class="o">&lt;-</span> <span class="o">(</span><span class="n">Qminus_le_l</span> <span class="o">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">a</span><span class="o">));</span> <span class="nb">ring_simplify</span><span class="o">.</span>
  <span class="nb">rewrite</span> <span class="o">&lt;-</span> <span class="o">(</span><span class="n">Qminus_le_l</span> <span class="o">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">c</span><span class="o">));</span> <span class="nb">ring_simplify</span><span class="o">.</span>
  <span class="n">Qeauto</span> <span class="nb">using</span> <span class="n">Qsqr_0</span><span class="o">.</span>
<span class="kn">Qed</span><span class="o">.</span></pre><img src="coq.png" class="rooster-sticker substep"></img><img src="magic.svg" class="magic-rooster substep"></img></div><div class="notes"><p>That's it.  You can check that the statement at the top matches what I wanted to prove, and there's a Qed at the end, and I promise that Coq actually accepts this, so&#x2026; all good?</p><p>Hey, I can even add a little rooster next to the proof to make it more convincing!
If this were a live talk I'd pause and ask people to raise their hands if they feel they understand this proof.  But since I'm alone at home talking to my camera instead, I'll just assume that you're like me, and that you don't find this pile of tactics particularly enlightening.</p><p>What are you supposed to do? Simulate Coq's tactic engine in your mind to understand what's going on?</p><p>What we're looking at together is not what mathematicians typically call &#x201C;a proof&#x201D;, because it's missing the proof states, which Coq calls &#x201C;goals&#x201D;.</p><p>What we're looking at is a proof <em>script</em>: a Coq program that records the steps that establish that a theorem holds.  It's made of a sequence of tactics, each of which correspond to a small amount of progress in the proof, like multiplying both sides of an inequality by a positive number or reasoning by induction.</p><p>What it does not record are the &#x201C;goals&#x201D;, the intermediate proof states that these steps lead to.  That's because, if you run the proof script in a Coq development environment, goals are automatically computed and displayed by Coq itself.  The downside is that this makes it nigh impossible to understand a proof script on its own, without running it.</p><p>In many cases we don't really care why a theorem is true, so it does not matter that the proof script is inscrutable.  Maybe I'm proving that a particular program does not perform out-of-bounds array accesses, for example, and it's enough for me to know that the theorem holds.  In those cases, if Coq is happy, I'm happy too.</p><p>But sometimes proofs do carry interesting insight.  Maybe there's a particularly tricky case that I'd like readers to think about, or maybe I'm using Coq proofs to communicate interesting mathematical ideas, or maybe I'm teaching students about simple math and logic concepts and using the computer to support my explanations and introduce formal reasoning.</p></div></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="13000" data-y="0" data-z="0"><img src="coqide.png" alt="CoqIDE showing a proof script and a goal." class="img-m"></img><div class="notes"><p>But sometimes proofs do carry interesting insight.  Maybe there's a particularly tricky case that I'd like readers to think about, or maybe I'm using Coq proofs to communicate interesting mathematical ideas, or maybe I'm teaching students about simple math and logic concepts and using the computer to support my explanations and introduce formal reasoning.</p><p>In those cases I want to show the reader what steps we took, and what states they led to.  That's easy to do in Coq if the readers have access to Coq: they can just feed the proof script to Coq in an interactive IDE and inspect the intermediate states that Coq computes and displays.</p><p>But maybe your readers don't have the right version of Coq installed.  Or maybe your proof has large dependencies that take a while to compile and your readers are just browsing casually.  Maybe they're on a mobile phone.  Maybe you're writing a book and, well, your readers can't run Coq on a physical book.</p><p>So what do people do to write manuals, tutorials, textbooks, blog posts, or any other piece of text that mixes Coq proofs and prose?</p></div></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="15600" data-y="0" data-z="0"><pre class="highlight code coq"><span class="kn">Lemma</span> <span class="nf">Qle_pairwise</span> <span class="o">:</span> <span class="kr">&#x2200;</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="o">,</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&#x2227;</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">&#x2227;</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">c</span> <span class="o">&#x2227;</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">d</span> <span class="o">&#x2192;</span>
  <span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="o">)/(</span><span class="n">b</span> <span class="o">+</span> <span class="n">d</span><span class="o">)</span> <span class="o">&#x2264;</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="o">/</span><span class="n">d</span><span class="o">.</span>
<span class="kn">Proof with</span> <span class="n">Qeauto</span><span class="o">.</span>
  <span class="nb">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">H</span><span class="o">.</span>
  <span class="sd">(** [(a + c) / (b + d) &#x2264; a / b + c / d] *)</span>
  <span class="nb">field_simplify</span><span class="o">...</span>
  <span class="sd">(** [(a + c) / (b + d) &#x2264; (a * d + c * b) / (b * d)] *)</span>
  <span class="nb">rewrite</span> <span class="o">&lt;-</span> <span class="o">(</span><span class="n">Qmult_le_l</span> <span class="o">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">d</span><span class="o">)),</span> <span class="n">Qmult_div_r</span><span class="o">,</span> <span class="n">Qmult_Qdiv_fact</span><span class="o">...</span>
  <span class="nb">rewrite</span> <span class="o">&lt;-</span> <span class="o">(</span><span class="n">Qmult_le_l</span> <span class="o">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">d</span><span class="o">)),</span> <span class="n">Qmult_div_r</span><span class="o">...</span>
  <span class="sd">(** [b * d * (a + c) &#x2264; (b + d) * (a * d + c * b)] *)</span>
  <span class="nb">field_simplify</span><span class="o">.</span>
  <span class="sd">(** [b * d * a + b * d * c &#x2264; b ^ 2 * c + b * d * a + b * d * c + d ^ 2 * a] *)</span>
  <span class="nb">rewrite</span> <span class="o">&lt;-</span> <span class="o">(</span><span class="n">Qminus_le_l</span> <span class="o">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">a</span><span class="o">));</span> <span class="nb">ring_simplify</span><span class="o">.</span>
  <span class="nb">rewrite</span> <span class="o">&lt;-</span> <span class="o">(</span><span class="n">Qminus_le_l</span> <span class="o">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">c</span><span class="o">));</span> <span class="nb">ring_simplify</span><span class="o">.</span>
  <span class="sd">(** [0 &#x2264; b ^ 2 * c + d ^ 2 * a] *)</span>
  <span class="n">Qeauto</span> <span class="nb">using</span> <span class="n">Qsqr_0</span><span class="o">.</span>
<span class="kn">Qed</span><span class="o">.</span></pre><div class="notes"><p>In most cases they do something like this: they run the proof in Coq and then, by hand, they copy the output of each tactic into source code comments.</p></div></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="18200" data-y="0" data-z="0"><pre class="highlight code coq"><span class="kn">Require Import</span> <span class="n">Arith</span><span class="o">.</span>
<span class="kn">Print</span> <span class="n">fact</span><span class="o">.</span>
<span class="sd">(** [[
fact =
fix fact (n : nat) : nat :=
  match n with
  | 0 =&gt; 1
  | S n0 =&gt; S n0 * fact n0
  end
     : nat -&gt; nat
]]
*)</span></pre><div class="notes"><p>Here's what it looks like in Certified Programming with Dependent Types.</p></div></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><pre class="highlight code coq"><span class="nb">pose</span> <span class="n">D</span> <span class="n">x</span> <span class="o">:=</span> <span class="kr">if</span> <span class="n">x</span> <span class="kr">is</span> <span class="mi">2</span> <span class="kr">then</span> <span class="kt">False</span> <span class="kr">else</span> <span class="kt">True</span><span class="o">.</span>

<span class="sd">(**
[[
  H : 2 === 1
  D := fun x : nat =&gt;
       match x with
       | 0 =&gt; True
       | 1 =&gt; True
       | 2 =&gt; False
       | S (S (S _)) =&gt; True
       end : nat -&gt; Prop
  ============================
   False
]] **)</span></pre><div class="notes"><p>Here's what it looks like in Illya's Programs and Proofs.</p></div></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="23400" data-y="0" data-z="0"><pre class="highlight code coq"><span class="sd">(** To check whether a particular proof relies on any additional
    axioms, use the [Print Assumptions] command.  *)</span>

<span class="kn">Print Assumptions</span> <span class="n">function_equality_ex2</span><span class="o">.</span>
<span class="c">(* ===&gt;
     Axioms:
     functional_extensionality :
         forall (X Y : Type) (f g : X -&gt; Y),
                (forall x : X, f x = g x) -&gt; f = g *)</span></pre><div class="notes"><p>Here's what it looks like in Software Foundations.</p><p>This is a particularly cumbersome process.  It takes a lot of work; it's easy to make mistakes; and it's very easy to forget to update the comments after changing a proof script.  There's also no way to check whether the comments are still valid, so you have to rely on readers to point issues as they discover them.</p></div></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="26000" data-y="0" data-z="0"><div class="alectryon-block"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk0" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">Qle_pairwise</span> : <span class="kr">&#8704;</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span>, <span class="mi">0</span> &lt; a &#8743; <span class="mi">0</span> &lt; b &#8743; <span class="mi">0</span> &lt; c &#8743; <span class="mi">0</span> &lt; d &#8594;
  (a + c)/(b + d) &#8804; a/b + c/d.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">&#8704;</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : Q,
  <span class="mi">0</span> &lt; a &#8743; <span class="mi">0</span> &lt; b &#8743; <span class="mi">0</span> &lt; c &#8743; <span class="mi">0</span> &lt; d &#8594; (a + c) / (b + d) &#8804; a / b + c / d</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk1" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk1"><span class="highlight"><span class="kn">Proof with</span> Qeauto.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">&#8704;</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : Q,
  <span class="mi">0</span> &lt; a &#8743; <span class="mi">0</span> &lt; b &#8743; <span class="mi">0</span> &lt; c &#8743; <span class="mi">0</span> &lt; d &#8594; (a + c) / (b + d) &#8804; a / b + c / d</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk2" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk2"><span class="highlight"><span class="nb">intros</span> a b c d H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(a + c) / (b + d) &#8804; a / b + c / d</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk3" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk3"><span class="highlight"><span class="nb">field_simplify</span>...</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(a + c) / (b + d) &#8804; (a * d + c * b) / (b * d)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk4" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk4"><span class="highlight"><span class="nb">rewrite</span> &lt;- (Qmult_le_l (b + d)), Qmult_div_r, Qmult_Qdiv_fact...</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a + c &#8804; (b + d) * (a * d + c * b) / (b * d)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk5" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk5"><span class="highlight"><span class="nb">rewrite</span> &lt;- (Qmult_le_l (b * d)), Qmult_div_r...</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b * d * (a + c) &#8804; (b + d) * (a * d + c * b)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk6" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk6"><span class="highlight"><span class="nb">field_simplify</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b * d * a + b * d * c &#8804; b ^ <span class="mi">2</span> * c + b * d * a + b * d * c + d ^ <span class="mi">2</span> * a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk7" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk7"><span class="highlight"><span class="nb">rewrite</span> &lt;- (Qminus_le_l (b * d * a)); <span class="nb">ring_simplify</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b * d * c &#8804; b ^ <span class="mi">2</span> * c + b * d * c + d ^ <span class="mi">2</span> * a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk8" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk8"><span class="highlight"><span class="nb">rewrite</span> &lt;- (Qminus_le_l (b * d * c)); <span class="nb">ring_simplify</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &#8804; b ^ <span class="mi">2</span> * c + d ^ <span class="mi">2</span> * a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">Qeauto <span class="nb">using</span> Qsqr_0.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span></pre></div><div class="notes"><p>There's got to be a better way, and that's where Alectryon comes in.</p><p>Alectryon is two things: first, it's a compiler that records Coq's output and embeds it within the proof script to create interactive proof visualizations, and second it's a literate programming system for Coq.</p><p>Here's that same proof as rendered by Alectryon.  Alectryon's compiler took the input Coq file, fed it to Coq, collected the output, formatted it, and generated a webpage interleaving inputs and outputs.</p><p>What you're looking at is an interactive webpage:  each input fragment of the original Coq script is a button that you can hover on or click to show or hide the corresponding proof state, along with any accompanying messages.</p><p>Every time I make changes to the Coq file I can re-run Alectryon, and it will update the visualization.  And because all outputs are recorded, browsing through the proof is instantaneous: there's no need to load a copy of Coq in your browser.</p><p>All of the layout and display is done in CSS, so you can actually change the rendering in all sorts of fancy ways, including in one style that mimics the usual interface that you see in a proof assistant, with the code on the left and the goals and messages on the right.</p></div></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28600" data-y="0" data-z="0"><div class="coq-mathjax"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk9" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk9"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">Qle_pairwise</span> : <span class="kr">&#8704;</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span>, <span class="mi">0</span> &lt; a &#8743; <span class="mi">0</span> &lt; b &#8743; <span class="mi">0</span> &lt; c &#8743; <span class="mi">0</span> &lt; d &#8594;
  (a + c)/(b + d) &#8804; a/b + c/d.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">\ccForall{a b c d : \ccQ{}}{<span class="mi">0</span> &lt; a \wedge
                            <span class="mi">0</span> &lt; b \wedge <span class="mi">0</span> &lt; c \wedge <span class="mi">0</span> &lt; d \Rightarrow{}
                            \ccFrac{ a + c }{ b + d} \le
                            \ccFrac{ a }{ b} + \ccFrac{ c }{ d}}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chka" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chka"><span class="highlight"><span class="kn">Proof with</span> Qeauto.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">\ccForall{a b c d : \ccQ{}}{<span class="mi">0</span> &lt; a \wedge
                            <span class="mi">0</span> &lt; b \wedge <span class="mi">0</span> &lt; c \wedge <span class="mi">0</span> &lt; d \Rightarrow{}
                            \ccFrac{ a + c }{ b + d} \le
                            \ccFrac{ a }{ b} + \ccFrac{ c }{ d}}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chkb" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chkb"><span class="highlight"><span class="nb">intros</span> a b c d H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">\ccFrac{ a + c }{ b + d} \le \ccFrac{ a }{ b} + \ccFrac{ c }{ d}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chkc" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chkc"><span class="highlight"><span class="nb">field_simplify</span>...</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">\ccFrac{ a + c }{ b + d} \le
\ccFrac{ a \times d + c \times b }{ b \times d}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chkd" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chkd"><span class="highlight"><span class="nb">rewrite</span> &lt;- (Qmult_le_l (b + d)), Qmult_div_r, Qmult_Qdiv_fact...</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a + c \le
\ccFrac{ (b + d) \times (a \times d + c \times b) }{ b \times d}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chke" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chke"><span class="highlight"><span class="nb">rewrite</span> &lt;- (Qmult_le_l (b * d)), Qmult_div_r...</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(b \times d) \times (a + c) \le
(b + d) \times (a \times d + c \times b)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chkf" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chkf"><span class="highlight"><span class="nb">field_simplify</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(b \times d) \times a + (b \times d) \times c \le
\ccPow{ b }{ <span class="mi">2</span>} \times c + (b \times d) \times a +
(b \times d) \times c + \ccPow{ d }{ <span class="mi">2</span>} \times a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk10" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk10"><span class="highlight"><span class="nb">rewrite</span> &lt;- (Qminus_le_l (b * d * a)); <span class="nb">ring_simplify</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(b \times d) \times c \le
\ccPow{ b }{ <span class="mi">2</span>} \times c + (b \times d) \times c +
\ccPow{ d }{ <span class="mi">2</span>} \times a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk11" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk11"><span class="highlight"><span class="nb">rewrite</span> &lt;- (Qminus_le_l (b * d * c)); <span class="nb">ring_simplify</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> \le \ccPow{ b }{ <span class="mi">2</span>} \times c + \ccPow{ d }{ <span class="mi">2</span>} \times a</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">Qeauto <span class="nb">using</span> Qsqr_0.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span></pre></div><div class="notes"><p>Also, since we're now in a web browser, we can make everything look extra-fancy thanks to the magic of Coq notations combined with JavaScript rendering of LaTeX code, and now I have a much more reasonable shot at getting you to understand the proof:</p><p>First we sum the two fractions on the right; then we expand the numerator; then we multiply both sides to get rid of the denominators; then we simplify and cancel on both sides, and lastly we use the fact that a square is always positive.</p><p>That's really what it is: you take a Coq document, you put little annotations to indicate which parts of the output should be displayed by default, and then Alectryon does the magic of running Coq and embedding its answers into your document.</p></div></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="31200" data-y="0" data-z="0"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">excl</span>: <span class="kr">&#8704;</span> <span class="nv">A</span>, A &#8744; ~ A).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk12" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk12"><span class="highlight"><span class="kn">Goal</span> <span class="kr">&#8704;</span> <span class="nv">A</span>, &#172;&#172;A &#8594; A.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">excl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">&#8704;</span> <span class="nv">A</span> : <span class="kt">Prop</span>, A &#8744; &#172; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">&#8704;</span> <span class="nv">A</span> : <span class="kt">Prop</span>, &#172; &#172; A &#8594; A</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk13" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk13"><span class="highlight"><span class="nb">intros</span> A notnot_A.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">excl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">&#8704;</span> <span class="nv">A0</span> : <span class="kt">Prop</span>, A0 &#8744; &#172; A0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">notnot_A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">&#172; &#172; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk14" style="display: none" type="checkbox"><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">(<span class="kr">&#955;</span> (<span class="nv">A</span> : <span class="kt">Prop</span>) (<span class="nv">notnot_A</span> : &#172; &#172; A), <span class="nl">?Goal</span>)</span></blockquote></div></div></small></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk15" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk15"><span class="highlight"><span class="nb">destruct</span> (excl A) <span class="kr">as</span> [a | na].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">excl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">&#8704;</span> <span class="nv">A0</span> : <span class="kt">Prop</span>, A0 &#8744; &#172; A0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">notnot_A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">&#172; &#172; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="talk-rst-chk16" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">excl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">&#8704;</span> <span class="nv">A0</span> : <span class="kt">Prop</span>, A0 &#8744; &#172; A0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">notnot_A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">&#172; &#172; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">na</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">&#172; A</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="talk-rst-chk16"><hr></label><div class="goal-conclusion"><span class="highlight">A</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk17" style="display: none" type="checkbox"><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">(<span class="kr">&#955;</span> (<span class="nv">A</span> : <span class="kt">Prop</span>) (<span class="nv">notnot_A</span> : &#172; &#172; A),
   <span class="kr">let</span> <span class="nv">o</span> : A &#8744; &#172; A := excl A <span class="kr">in</span>
   <span class="kr">match</span> o <span class="kr">with</span>
   | or_introl a =&gt; <span class="nl">?Goal</span>
   | or_intror na =&gt; <span class="nl">?Goal0</span>
   <span class="kr">end</span>)</span></blockquote></div></div></small></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk18" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk18"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">excl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">&#8704;</span> <span class="nv">A0</span> : <span class="kt">Prop</span>, A0 &#8744; &#172; A0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">notnot_A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">&#172; &#172; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk19" style="display: none" type="checkbox"><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">(<span class="kr">&#955;</span> (<span class="nv">A</span> : <span class="kt">Prop</span>) (<span class="nv">notnot_A</span> : &#172; &#172; A),
   <span class="kr">let</span> <span class="nv">o</span> : A &#8744; &#172; A := excl A <span class="kr">in</span>
   <span class="kr">match</span> o <span class="kr">with</span>
   | or_introl a =&gt; a
   | or_intror na =&gt; <span class="nl">?Goal</span>
   <span class="kr">end</span>)</span></blockquote></div></div></small></span></pre><div class="notes"><p>Here's an example of hiding parts of the input to show something slightly different: part of teaching students about Coq involves explaining the Curry&#x2013;Howard correspondence by showing how tactics construct proof terms under the hood.  In this example, I've added hidden calls to the Coq command &#x201C;Show Proof&#x201D; between each line, and Alectryon shows the piecemeal construction of a proof term.</p></div></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33800" data-y="0" data-z="0"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="sd">(** So far, it looks like co-inductive types might be a magic</span>
<span class="sd">    bullet, allowing us to import all of the</span>
<span class="sd">    Haskeller&#39;s usual tricks. &#8230;</span>

<span class="sd">    The restriction for co-inductive types shows up as</span>
<span class="sd">    the%\index{guardedness condition}% _guardedness</span>
<span class="sd">    condition_.  First, consider this stream definition,</span>
<span class="sd">    which would be legal in Haskell.</span>

<span class="sd">    [[</span>
<span class="sd">    CoFixpoint looper : stream nat := looper.</span>
<span class="sd">    ]]</span>

<span class="sd">    &lt;&lt;</span>
<span class="sd">    Error:</span>
<span class="sd">    Recursive definition of looper is ill-formed.</span>
<span class="sd">    In environment</span>
<span class="sd">    looper : stream nat</span>
<span class="sd">    unguarded recursive call in &quot;looper&quot;</span>
<span class="sd">    &gt;&gt; **)</span></span></span></pre><div class="notes"><p>Ok, so this solves the problem of displaying goals and outputs to readers, but that's just one part of writing a document that includes Coq proofs: the other part is writing the explanatory prose that accompanies the proofs.</p><p>In fact, if you inspect this example from CPDT closely, you'll notice that there's no actual code here &#x2014; it's all prose in comments!
There's lots and lots of prose around the code: in fact, there's a whole book in there, written within source code comments.</p><p>I have a lot of respect for the authors of all these Coq books.  It takes a whole different level of grit and determination to edit a whole book out of source code comments, and the books that I mentioned are some of the best Coq books out there.</p></div></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36400" data-y="0" data-z="0"><pre class="highlight code coq"><span class="sd">(*|
A fairly common occurrence when working with dependent
types in Coq is to call `Compute` on a benign expression
and get back a giant, partially-reduced term, like this:
|*)</span>

<span class="kn">Import</span> <span class="n">EqNotations</span> <span class="n">Vector</span><span class="o">.</span><span class="n">VectorNotations</span><span class="o">.</span>
<span class="kn">Compute</span> <span class="o">(</span><span class="n">hd</span> <span class="o">(</span><span class="n">rew</span> <span class="o">(</span><span class="n">Nat</span><span class="o">.</span><span class="n">add_1_r</span> <span class="mi">3</span><span class="o">)</span>
                 <span class="kr">in</span> <span class="o">([</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">]</span> <span class="o">++</span> <span class="o">[</span><span class="mi">4</span><span class="o">]))).</span> <span class="c">(* .unfold *)</span>

<span class="sd">(*|
This post shows how to work around this issue.
|*)</span></pre><div class="notes"><p>Again, it shouldn't have to be this way.  My text editor has all sorts of nifty features for editing Markdown or reStructuredText documents, like smart navigation, spell-checking, live previews, and convenient shortcuts, so it's particularly frustrating when I end up having to write all my code inside Coq comments.</p><p>Alectryon has an answer for that as well: it includes a suite of literate programming tools for Coq that make it much easier to create and edit documents that mix prose and proofs.</p><p>The code you're looking at on this screen is a snippet from a blog post I wrote recently. When you give Alectryon a Coq file, it can compile it to a webpage, but it can also generate a reStructuredText file by partitioning the Coq sources into a sequence of code and comment blocks, extracting the comments, and wrapping each code fragment into a reStructuredText code block.</p></div></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="39000" data-y="0" data-z="0"><pre class="highlight code rst">A fairly common occurrence when working with dependent
types in Coq is to call <span class="nv">`Compute`</span> on a benign expression
and get back a giant, partially-reduced term, like this:

<span class="p">..</span> <span class="ow">coq</span><span class="p">::</span>

   Import EqNotations Vector.VectorNotations.
   Compute (hd (rew (Nat.add_1_r 3)
                    in ([1; 2; 3] ++ [4]))). (<span class="ge">* .unfold *</span>)

This post shows how to work around this issue.</pre><div class="notes"><p>This is what it looks like after flipping the code and the prose around.  The syntax is reStructuredText.  reStructuredText is a great markup language, very much like Markdown but with a robust story for writing extensions; in fact, I used this whole presentation is just one large Coq file; I used Alectryon to convert it to reStructuredText.</p><p>The best part is that you can go back: once you're done editing the prose of your document and you're ready to resume hacking on the proofs, you can use Alectryon to convert the reStructuredText file back into a Coq source file, in which the prose is wrapped in special comments and the code is at the top level.  Here, let's go back to the original code.</p></div></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><img src="emacs-screenshot.svg" alt="A screenshot of Emacs shows the same snippet from Software foundations, in code and prose views."></img><div class="notes"><p>These two transformations are the inverse of one another, so you can switch between the code-oriented view and the prose-oriented view at will.  This is trivial to integrate into an IDE; I did it for Emacs, and I'm sure it would be very easy to do in any other editor.</p><p>Being able to go back and forth between reStructuredText and Coq means that Alectryon does not have to implement its own markup language for literate comments: it can just piggyback on the existing reStructuredText toolchain, which is very robust and used by a lot of people for all sorts of documents, like the reference manuals of Python, Agda, Haskell, and a host of other languages &#x2014; including Coq.</p></div></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44200" data-y="0" data-z="0"><div class="xxxl"><p><span class="red">&#x2717;</span> LaTeX &#x2190; literate document &#x2192; Coq</p><p><span class="green">&#x2713;</span> reST &#x21C6; Coq</p></div><div class="notes"><p>If you're familiar with literate programming, you might notice that this is a bit different from the usual process.  Normally, in systems like WEB or org-mode, you start with a main document, which you can either &#x201C;tangle&#x201D; to get executable source code, or &#x201C;weave&#x201D; to get a document suitable for typesetting or reading, like LaTeX or HTML.  But in most cases, it's not particularly easy to edit the generated code and mirror these edits back into the original sources.</p><p>It does not matter too much for regular programming languages, although it does make it trickier to use tools like linters or debuggers.</p><p>But for a Coq proof, you really want to be able to step through the proofs interactively while you're writing them, and that's why most proof-heavy Coq literature is written in Coqdoc, with the prose embedded inside comments.</p><p>So that's what Alectryon does: it gives you bidirectional editing, which allows you to toggle between code and prose seamlessly, so you're free to use the most appropriate editing environment at all times.</p><p>Importantly, there's no preferred view of a document: you can pick either the reStructuredText view or the Coq view as the one you store and distribute.  For a literate Coq library you would probably distribute the code-oriented view so that users can compile your files as regular Coq sources without having to know anything about Alectryon, and for a book with a few Coq examples you might distribute reStructuredText files instead.</p></div></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="46800" data-y="0" data-z="0"><h1 id="implementation">Implementation</h1><div class="s"><dl><dt>Generate an interactive webpage from a literate Coq file with reST comments (Coqdoc style):</dt><dd><pre class="highlight code">../alectryon.py literate.v</pre></dd><dt>Generate an interactive webpage from a plain Coq file (Proof General style):</dt><dd><pre class="highlight code">../alectryon.py --frontend coq plain.v</pre></dd><dt>Generate an interactive webpage from a Coqdoc file (compatibility mode):</dt><dd><pre class="highlight code">../alectryon.py --frontend coqdoc literate.v</pre></dd><dt>Compile a reStructuredText document containing <tt>.. coq::</tt> blocks (coqrst style):</dt><dd><pre class="highlight code">../alectryon.py literate.v.rst</pre></dd><dt>Translate a reStructuredText document into a literate Coq file:</dt><dd><pre class="highlight code">../alectryon.py literate.v.rst -o literate.v</pre></dd><dt>Translate a literate Coq file into a reStructuredText document:</dt><dd><pre class="highlight code">../alectryon.py literate.v -o literate.v.rst</pre></dd><dt>Record goals and responses for fragments contained in a JSON source file:</dt><dd><pre class="highlight code">../alectryon.py fragments.json</pre></dd><dt>Record goals and responses and format them as HTML for fragments contained in a JSON source file:</dt><dd><pre class="highlight code">../alectryon.py fragments.json -o fragments.snippets.html</pre></dd></dl></div><div class="notes"><p>Now that I've given you a sense of what Alectryon does, let me say a bit about how it does it.</p><p>Alectryon is a Python program, and it's written as a collection of mostly independent modules:</p></div></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="49400" data-y="0" data-z="0"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* Can you favorite IDE handle this?</span>
<span class="c">   (mine can&#39;t, and I&#39;m one of the maintainers&#8230;) *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( a . b )&quot;</span> := (a, b).</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk1a" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk1a"><span class="highlight"><span class="kn">Check</span> (<span class="mi">0</span> . <span class="mi">1</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">(<span class="mi">0</span> . <span class="mi">1</span>)
     : nat * nat</span></blockquote></div></div></small></span></pre><div class="notes"><p>A &#x201C;core&#x201D; module handles communication with Coq through the SerAPI protocol.  An interesting technical challenge is sentence segmentation: Coq's notation system makes it almost impossible to determine where a Coq sentence starts or ends, so we use Coq's APIs directly for this.</p></div></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="52000" data-y="0" data-z="0"><div class="coq-mathjax"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk1b" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk1b"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">Gauss</span>: <span class="kr">&#8704;</span> <span class="nv">n</span>, <span class="mi">2</span> * (nsum n (<span class="kr">fun</span> <span class="nv">i</span> =&gt; i)) = n * (n + <span class="mi">1</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">\ccForall{n : \ccNat{}}{<span class="mi">2</span> \times \ccNsum{i}{n}{i} = n \times (n + <span class="mi">1</span>)}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk1c" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk1c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">\ccForall{n : \ccNat{}}{<span class="mi">2</span> \times \ccNsum{i}{n}{i} = n \times (n + <span class="mi">1</span>)}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk1d" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk1d"><span class="highlight"><span class="nb">induction</span> n; <span class="nb">cbn</span> [nsum].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> \times <span class="mi">0</span> = <span class="mi">0</span> \times (<span class="mi">0</span> + <span class="mi">1</span>)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="talk-rst-chk1e" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">\ccNat{}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">2</span> \times \ccNsum{i}{n}{i} = n \times (n + <span class="mi">1</span>)</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="talk-rst-chk1e"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> \times (\ccSucc{ n} + \ccNsum{i}{n}{i}) =
\ccSucc{ n} \times (\ccSucc{ n} + <span class="mi">1</span>)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk1f" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk1f"><span class="highlight">- <span class="c">(* n &#8592; 0 *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> \times <span class="mi">0</span> = <span class="mi">0</span> \times (<span class="mi">0</span> + <span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk20" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk20"><span class="highlight">- <span class="c">(* n &#8592; S _ *)</span></span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">\ccNat{}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">2</span> \times \ccNsum{i}{n}{i} = n \times (n + <span class="mi">1</span>)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> \times (\ccSucc{ n} + \ccNsum{i}{n}{i}) =
\ccSucc{ n} \times (\ccSucc{ n} + <span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk21" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk21"><span class="highlight"><span class="nb">rewrite</span> Mult.mult_plus_distr_l.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> \times \ccSucc{ n} + <span class="mi">2</span> \times \ccNsum{i}{n}{i} =
\ccSucc{ n} \times (\ccSucc{ n} + <span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk22" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk22"><span class="highlight"><span class="nb">rewrite</span> IHn.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">2</span> \times \ccSucc{ n} + n \times (n + <span class="mi">1</span>) =
\ccSucc{ n} \times (\ccSucc{ n} + <span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">ring</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span></pre></div><div class="notes"><p>A &#x201C;transforms&#x201D; module improves the rendering of the results and processes display annotations that specify which parts of the output to show or hide by default.</p><p>This module can accommodate user-specified transforms, which make it possible to special-case the rendering of certain types or constructs and generally customize the output (as an alternative, you can also customize the output by running JavaScript directly in the browser).</p></div></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="54600" data-y="0" data-z="0"><script src="https://d3js.org/d3.v5.min.js" charset="utf-8"></script>
<script src="https://dagrejs.github.io/project/dagre-d3/latest/dagre-d3.js"></script><div class="rbt-no-printing"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">build_trees</span> (<span class="nv">leaves</span>: list nat) :=
  List.fold_left (<span class="kr">fun</span> <span class="nv">trs</span> <span class="nv">n</span> =&gt; RBT.add n (hd RBT.empty trs) :: trs)
    leaves [] |&gt; List.rev.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk23" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk23"><span class="highlight"><span class="kn">Compute</span> build_trees [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>;<span class="mi">4</span>;<span class="mi">5</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">= [{|
   RBT.this := RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">1</span> RBT.Raw.Leaf;
   RBT.is_ok := RBT.Raw.add_ok RBT.Raw.Leaf <span class="mi">1</span> |};
  {|
  RBT.this := RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">1</span>
                (RBT.Raw.Node Red RBT.Raw.Leaf <span class="mi">2</span> RBT.Raw.Leaf);
  RBT.is_ok := RBT.Raw.add_ok
                 (RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">1</span> RBT.Raw.Leaf)
                 <span class="mi">2</span> |};
  {|
  RBT.this := RBT.Raw.Node Black
                (RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">1</span> RBT.Raw.Leaf)
                <span class="mi">2</span>
                (RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">3</span> RBT.Raw.Leaf);
  RBT.is_ok := RBT.Raw.add_ok
                 (RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">1</span>
                    (RBT.Raw.Node Red RBT.Raw.Leaf <span class="mi">2</span>
                       RBT.Raw.Leaf)) <span class="mi">3</span> |};
  {|
  RBT.this := RBT.Raw.Node Black
                (RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">1</span> RBT.Raw.Leaf)
                <span class="mi">2</span>
                (RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">3</span>
                   (RBT.Raw.Node Red RBT.Raw.Leaf <span class="mi">4</span> RBT.Raw.Leaf));
  RBT.is_ok := RBT.Raw.add_ok
                 (RBT.Raw.Node Black
                    (RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">1</span>
                       RBT.Raw.Leaf) <span class="mi">2</span>
                    (RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">3</span>
                       RBT.Raw.Leaf)) <span class="mi">4</span> |};
  {|
  RBT.this := RBT.Raw.Node Black
                (RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">1</span> RBT.Raw.Leaf)
                <span class="mi">2</span>
                (RBT.Raw.Node Red
                   (RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">3</span>
                      RBT.Raw.Leaf) <span class="mi">4</span>
                   (RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">5</span>
                      RBT.Raw.Leaf));
  RBT.is_ok := RBT.Raw.add_ok
                 (RBT.Raw.Node Black
                    (RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">1</span>
                       RBT.Raw.Leaf) <span class="mi">2</span>
                    (RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">3</span>
                       (RBT.Raw.Node Red RBT.Raw.Leaf <span class="mi">4</span>
                          RBT.Raw.Leaf))) <span class="mi">5</span> |}]
: list RBT.t</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk24" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk24"><span class="highlight"><span class="kn">Compute</span> build_trees [<span class="mi">2</span>;<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">3</span>;<span class="mi">6</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">= [{|
   RBT.this := RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">2</span> RBT.Raw.Leaf;
   RBT.is_ok := RBT.Raw.add_ok RBT.Raw.Leaf <span class="mi">2</span> |};
  {|
  RBT.this := RBT.Raw.Node Black
                (RBT.Raw.Node Red RBT.Raw.Leaf <span class="mi">1</span> RBT.Raw.Leaf) <span class="mi">2</span>
                RBT.Raw.Leaf;
  RBT.is_ok := RBT.Raw.add_ok
                 (RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">2</span> RBT.Raw.Leaf)
                 <span class="mi">1</span> |};
  {|
  RBT.this := RBT.Raw.Node Black
                (RBT.Raw.Node Red RBT.Raw.Leaf <span class="mi">1</span> RBT.Raw.Leaf) <span class="mi">2</span>
                (RBT.Raw.Node Red RBT.Raw.Leaf <span class="mi">4</span> RBT.Raw.Leaf);
  RBT.is_ok := RBT.Raw.add_ok
                 (RBT.Raw.Node Black
                    (RBT.Raw.Node Red RBT.Raw.Leaf <span class="mi">1</span>
                       RBT.Raw.Leaf) <span class="mi">2</span> RBT.Raw.Leaf) <span class="mi">4</span> |};
  {|
  RBT.this := RBT.Raw.Node Black
                (RBT.Raw.Node Black
                   (RBT.Raw.Node Red RBT.Raw.Leaf <span class="mi">1</span> RBT.Raw.Leaf)
                   <span class="mi">2</span> RBT.Raw.Leaf) <span class="mi">3</span>
                (RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">4</span> RBT.Raw.Leaf);
  RBT.is_ok := RBT.Raw.add_ok
                 (RBT.Raw.Node Black
                    (RBT.Raw.Node Red RBT.Raw.Leaf <span class="mi">1</span>
                       RBT.Raw.Leaf) <span class="mi">2</span>
                    (RBT.Raw.Node Red RBT.Raw.Leaf <span class="mi">4</span>
                       RBT.Raw.Leaf)) <span class="mi">3</span> |};
  {|
  RBT.this := RBT.Raw.Node Black
                (RBT.Raw.Node Black
                   (RBT.Raw.Node Red RBT.Raw.Leaf <span class="mi">1</span> RBT.Raw.Leaf)
                   <span class="mi">2</span> RBT.Raw.Leaf) <span class="mi">3</span>
                (RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">4</span>
                   (RBT.Raw.Node Red RBT.Raw.Leaf <span class="mi">6</span> RBT.Raw.Leaf));
  RBT.is_ok := RBT.Raw.add_ok
                 (RBT.Raw.Node Black
                    (RBT.Raw.Node Black
                       (RBT.Raw.Node Red RBT.Raw.Leaf <span class="mi">1</span>
                          RBT.Raw.Leaf) <span class="mi">2</span> RBT.Raw.Leaf) <span class="mi">3</span>
                    (RBT.Raw.Node Black RBT.Raw.Leaf <span class="mi">4</span>
                       RBT.Raw.Leaf)) <span class="mi">6</span> |}]
: list RBT.t</span></blockquote></div></div></small><span class="coq-wsp">
</span></span></pre></div><div class="notes"><p>Here are two concrete examples: in this first one, I'm trying to get a better sense of the internal workings of Coq's red-black trees, so I'm progressively adding elements and seeing how the resulting trees look.  The default output isn't very convincing.</p></div></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="57200" data-y="0" data-z="0"><div class="rbt-render"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">build_trees</span> (<span class="nv">leaves</span>: list nat) :=
  List.fold_left (<span class="kr">fun</span> <span class="nv">trs</span> <span class="nv">n</span> =&gt; RBT.add n (hd RBT.empty trs) :: trs)
    leaves [] |&gt; List.rev.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk25" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk25"><span class="highlight"><span class="kn">Compute</span> build_trees [<span class="mi">1</span>;<span class="mi">2</span>;<span class="mi">3</span>;<span class="mi">4</span>;<span class="mi">5</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">= [{ &#39;tree&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">1</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } }};
  { &#39;tree&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">1</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Red&#39;; &#39;value&#39;: &#39;<span class="mi">2</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } } }};
  { &#39;tree&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">2</span>&#39;; &#39;left&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">1</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } }; &#39;right&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">3</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } } }};
  { &#39;tree&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">2</span>&#39;; &#39;left&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">1</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } }; &#39;right&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">3</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Red&#39;; &#39;value&#39;: &#39;<span class="mi">4</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } } } }};
  { &#39;tree&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">2</span>&#39;; &#39;left&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">1</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } }; &#39;right&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Red&#39;; &#39;value&#39;: &#39;<span class="mi">4</span>&#39;; &#39;left&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">3</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } }; &#39;right&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">5</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } } } }}]
: list RBT.t</span></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk26" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk26"><span class="highlight"><span class="kn">Compute</span> build_trees [<span class="mi">2</span>;<span class="mi">1</span>;<span class="mi">4</span>;<span class="mi">3</span>;<span class="mi">6</span>].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-messages"><blockquote class="coq-message"><span class="highlight">= [{ &#39;tree&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">2</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } }};
  { &#39;tree&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">2</span>&#39;; &#39;left&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Red&#39;; &#39;value&#39;: &#39;<span class="mi">1</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } }};
  { &#39;tree&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">2</span>&#39;; &#39;left&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Red&#39;; &#39;value&#39;: &#39;<span class="mi">1</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } }; &#39;right&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Red&#39;; &#39;value&#39;: &#39;<span class="mi">4</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } } }};
  { &#39;tree&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">3</span>&#39;; &#39;left&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">2</span>&#39;; &#39;left&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Red&#39;; &#39;value&#39;: &#39;<span class="mi">1</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } }; &#39;right&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">4</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } } }};
  { &#39;tree&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">3</span>&#39;; &#39;left&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">2</span>&#39;; &#39;left&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Red&#39;; &#39;value&#39;: &#39;<span class="mi">1</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } }; &#39;right&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Black&#39;; &#39;value&#39;: &#39;<span class="mi">4</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;:&#39;node&#39;; &#39;color&#39;: &#39;Red&#39;; &#39;value&#39;: &#39;<span class="mi">6</span>&#39;; &#39;left&#39;: { &#39;kind&#39;: &#39;leaf&#39; }; &#39;right&#39;: { &#39;kind&#39;: &#39;leaf&#39; } } } }}]
: list RBT.t</span></blockquote></div></div></small><span class="coq-wsp">
</span></span></pre></div><div class="notes"><p>Now here's the same thing, but rendered using a graph library to display the trees, which makes it clear how the structure of the trees is affected by the order in which elements are added.</p></div></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="59800" data-y="0" data-z="0"><img src="udiv.opt.paths.svg" alt="A piece of Coq code showing a binary object rendered by passing it to objdump and highlighting the result."></img><div class="notes"><p>In this second example, I have a hypothetical compiler that takes C code and produces a binary.  What I've done here is ask Alectryon to take the bytes printed by Coq; call <tt><span class="n">objdump</span></tt> on them to get an assembly code listing; highlight <em>that</em> using Pygments; and then inline the result into the output.</p></div></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="62400" data-y="0" data-z="0"><img src="rss.paths.svg" class="img-m"></img><div class="notes"><p>An HTML module translates a recorded Coq session to HTML; this is mostly straightforward, though we're doubly careful to produce good code to make sure that the result works without JavaScript and looks decent even without CSS; that's because if you write a blog, for example, many people will read it through an RSS feed and these mostly don't support CSS.</p></div></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="65000" data-y="0" data-z="0"><pre class="highlight code coq"><span class="kn">Check</span> <span class="s2">"Where does this string (|* end? "</span><span class="o">.</span>
<span class="sd">(*| And where does `"this comment *|)` end?" |*)</span>
<span class="kn">Check</span> <span class="s2">"here? *)"</span><span class="o">.</span></pre><pre class="highlight code rst"><span class="p">..</span> <span class="ow">coq</span><span class="p">::</span>

   Check "Where does this string (|* end? ".

And where does <span class="nv">`"this comment *|)`</span> end?"

<span class="p">..</span> <span class="ow">coq</span><span class="p">::</span>

   Check "here? *)".</pre><div class="notes"><p>A &#x201C;literate&#x201D; module is in charge of tangling and untangling, from Coq to reStructuredText and back.
Starting from Coq it's just a matter of identifying comments, which we do using a recursive descent parser (it's harder than it looks, because the rules governing Coq comments and strings are pretty tricky to get right; so tricky that it trips up the syntax highlighter that I'm using for this presentation).</p><p>Starting from reST we use the standard reST parser to delimit sections of code and comments, and we jump through a few hoops to make indentation work out.</p><p>In both directions we keep track of source code positions; this makes the process quite a bit trickier, but it allows us to keep the position that the user is looking at when they switch from one view to the other; this is pretty crucial to ensure a nice experience when toggling between the code and prose views.  As a bonus, it allows us to run the reStructuredText syntax checker in the background when the user is in the Coq view and translate error positions to display them at the right place in the Coq view.</p></div></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="67600" data-y="0" data-z="0"><img src="sphinx.png" class="img-m"></img><div class="notes"><p>A &#x201C;docutils&#x201D; and a &#x201C;sphinx&#x201D; modules plug Alectryon into popular reStructuredText compilation toolchains to allow users to include bits of Coq code into larger documents and compile them with their favorite tools.</p></div></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="70200" data-y="0" data-z="0"><h1 id="evaluation">Evaluation</h1><div class="notes"><p>The paper has a lot of evaluation, and I encourage you to check it out if you're curious; in brief, the evaluation is organized around two axes:</p></div></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="72800" data-y="0" data-z="0"><img src="polymorphic-universes-8-12.svg" class="img-m"></img><div class="notes"><p>The first experiment is intended to evaluate Alectryon's robustness: we've compiled plenty of documents and Coq libraries, totally tens of thousands of lines of code and thousands of printed pages, and the approach seems pretty robust.  We can compile all of Coq's standard library, various blog posts, chapters excerpted from various books, and even a complete volume from Software Foundations.</p><p>If you're familiar with some of the books I mentioned then you may be wondering how this actually works, because most of them are written in Coqdoc, not in reStructuredText, and I've said before that Alectryon processes reStructuredText documents.</p><p>That's actually a neat example of Alectryon's extensibility.  What we do for Coqdoc documents, instead of asking their authors to port them to reStructuredText, is to render the code and Coq's output with Alectryon, but we run Coqdoc for the prose part and we incorporate the HTML that it generates into the webpages that we produce.</p></div></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="75400" data-y="0" data-z="0"><div class="twocolumns"><img src="stdlib.paths.svg" class="img-stdlib"></img><img src="breakdowns.paths.svg" class="img-breakdowns"></img></div><div class="notes"><p>The second axis measures Alectryon's speed.  All the graphs are in the paper, but the long story short is that Alectryon has a median overhead of 3x on compilation times (90% of all files fall below 7x), and a good 1/3 of that is communication overhead that can probably be eliminated in the future.  The rest is the overhead of collecting and formatting goals, which can be pretty costly for files that have a many goals.</p></div></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="78000" data-y="0" data-z="0"><h1 id="related-work">Related work</h1><img src="citations.paths.svg"></img><div class="notes"><p>It's hard to do justice to all the related work in this area in just a few minutes, so I'll simply say that Alectryon builds on decades of great ideas for making programs and proofs more understandable, all the way from a paper in 1980 co-authored by Eric Schmidt and Phil Wadler to PhD theses written just a year ago.  There's 60 citations and three pages of related work in the paper; if you're curious about the history of this stuff, you should really have a look.</p></div></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="80600" data-y="0" data-z="0"><div class="xxxl"><div class="line-block"><a href="https://github.com/cpitclaudel/alectryon/">https://github.com/cpitclaudel/alectryon/</a><br></br><a href="https://alectryon-paper.github.io/">https://alectryon-paper.github.io/</a><br></br></div></div><div class="notes"><p>To recap, Alectryon provides an architecture to record and visualize Coq proofs, facilitating sharing and interactive exploration of proof scripts; and a bidirectional translator between woven and tangled documents, enabling seamless editing of prose and code.</p><p>Alectryon is freely available on GitHub, and it's already used in the wild.  We use it for our group blog, I know someone is trying to use it for their Coq documentation at their company, and there's even 3rd-party packages starting to pop up to integrate it with other blogging platforms.  I'm sure some day a kind soul will help me figure out how to put it on OPAM, too.  Or maybe on the Python package index.</p></div></div><div class="step step-level-1" step="32" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="83200" data-y="0" data-z="0"><div class="xxxxl"><div class="math-block ">$$\begin{align}\LaTeX\end{align}$$</div></div><div class="notes"><p>Maybe I can conclude with a few words about the next steps.  Here are some directions that I'm exploring or would like help exploring.
First, I'd like to make a LaTeX backend: reStructuredText can produce LaTeX in addition to HTML, so it would make sense to support that as well.  I have a branch for this, and it's almost ready.</p></div></div><div class="step step-level-1" step="33" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="85800" data-y="0" data-z="0"><img src="life.svg"></img><div class="notes"><p>Second, I'd like to explore advanced visualizations further.  There are many domains for which the natural visualization for a piece of data is not text.  I have a few examples in the paper, but I'd like to push that idea further.  In fact, what would be really neat would be to settle on a standard for Coq developments to specify how to render a particular type.  I'm thinking of display-only notations that would produce images, graphs, plots, etc.  Once we have this, we could even integrate it with IDEs and finally stop envying the Racket folks with their magic picture tricks.</p></div></div><div class="step step-level-1" step="34" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="88400" data-y="0" data-z="0"><pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk27" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk27"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">interp_sound</span>: <span class="kr">forall</span> (<span class="nv">p</span>: Prog) (<span class="nv">gamma</span>: <span class="kp">context</span>) (<span class="nv">v</span>: Value),
    ComputesTo p (interp gamma p).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">&#8704;</span> (<span class="nv">p</span> : Prog) (<span class="nv">gamma</span> : <span class="kp">context</span>), Value &#8594; ComputesTo p (interp gamma p)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk28" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk28"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">&#8704;</span> (<span class="nv">p</span> : Prog) (<span class="nv">gamma</span> : <span class="kp">context</span>), Value &#8594; ComputesTo p (interp gamma p)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk29" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk29"><span class="highlight"><span class="nb">induction</span> p; <span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">gamma</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Value</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ComputesTo Boring0 (interp gamma Boring0)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="talk-rst-chk2a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">gamma</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Value</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="talk-rst-chk2a"><hr></label><div class="goal-conclusion"><span class="highlight">ComputesTo Boring1 (interp gamma Boring1)</span></div></blockquote><input class="coq-extra-goal-toggle" id="talk-rst-chk2b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">var</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">string</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1, p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Prog</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHp1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">&#8704;</span> <span class="nv">gamma0</span> : <span class="kp">context</span>, Value &#8594; ComputesTo p1 (interp gamma0 p1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHp2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">&#8704;</span> <span class="nv">gamma0</span> : <span class="kp">context</span>, Value &#8594; ComputesTo p2 (interp gamma0 p2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gamma</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Value</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="talk-rst-chk2b"><hr></label><div class="goal-conclusion"><span class="highlight">ComputesTo (Bind var p1 p2) (interp gamma (Bind var p1 p2))</span></div></blockquote><input class="coq-extra-goal-toggle" id="talk-rst-chk2c" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">gamma</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Value</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="talk-rst-chk2c"><hr></label><div class="goal-conclusion"><span class="highlight">ComputesTo Boring2 (interp gamma Boring2)</span></div></blockquote><input class="coq-extra-goal-toggle" id="talk-rst-chk2d" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">gamma</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Value</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="talk-rst-chk2d"><hr></label><div class="goal-conclusion"><span class="highlight">ComputesTo Boring3 (interp gamma Boring3)</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk2e" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk2e"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">gamma</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Value</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ComputesTo Boring0 (interp gamma Boring0)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">t.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk2f" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk2f"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">gamma</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Value</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ComputesTo Boring1 (interp gamma Boring1)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">t.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk30" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk30"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">var</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">string</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1, p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Prog</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHp1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">&#8704;</span> <span class="nv">gamma0</span> : <span class="kp">context</span>, Value &#8594; ComputesTo p1 (interp gamma0 p1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHp2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">&#8704;</span> <span class="nv">gamma0</span> : <span class="kp">context</span>, Value &#8594; ComputesTo p2 (interp gamma0 p2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gamma</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Value</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ComputesTo (Bind var p1 p2) (interp gamma (Bind var p1 p2))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input checked="checked" class="coq-toggle" id="talk-rst-chk31" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk31"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">var</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">string</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1, p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Prog</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHp1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">&#8704;</span> <span class="nv">gamma0</span> : <span class="kp">context</span>, Value &#8594; ComputesTo p1 (interp gamma0 p1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHp2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">&#8704;</span> <span class="nv">gamma0</span> : <span class="kp">context</span>, Value &#8594; ComputesTo p2 (interp gamma0 p2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gamma</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Value</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ComputesTo (Bind var p1 p2)
  (interp ((var . interp gamma p1) :: gamma) p2)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">&#8230;.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk32" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk32"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">gamma</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Value</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ComputesTo Boring2 (interp gamma Boring2)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">t.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="talk-rst-chk33" style="display: none" type="checkbox"><label class="coq-input" for="talk-rst-chk33"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">gamma</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">context</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Value</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ComputesTo Boring3 (interp gamma Boring3)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight">t.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="notes"><p>Third, for all the machine learning wizards out there, I'd like to explore automatic proof summarization &#x2014; just like automatically identifying the most exciting moments of a soccer game, but for Coq proofs.  More formally, the task is to automatically identify a small subset of proof steps that lead to particularly interesting or relevant goals; we'd use this in combination with Alectryon to identify the most interesting parts of a proof development.</p></div></div><div class="step step-level-1" step="35" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="91000" data-y="0" data-z="0"><img src="provers.svg"></img><div class="notes"><p>Finally, I'd like to extend the system to other languages, both for the markup side and for the Coq side.  I built Alectryon with Coq and reStructuredText, but very little of it is actually Coq or reStructuredText specific.</p><p>To port Alectryon to a different language, like Lean for example, you would need to add a Python module that invokes Lean and collects its output, and if you also wanted the literate programming support you'd want to make a bidirectional translator for Lean's comment syntax.</p><p>The literate programming parts were actually inspired by work that I did for F* a few years ago, so adding new languages really shouldn't be too hard.  If you're interested in getting Alectryon to work with your favorite proof assistant, please get in touch.</p></div></div><div class="step step-level-1" step="36" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="93600" data-y="0" data-z="0"><div class="xxxl"><div class="line-block"><a href="https://github.com/cpitclaudel/alectryon/">https://github.com/cpitclaudel/alectryon/</a><br></br><a href="https://alectryon-paper.github.io/">https://alectryon-paper.github.io/</a><br></br></div></div><div class="notes"><p>Thanks for your attention!  Feel free to reach out if you have questions, and check the README and the paper for lots of extra info.</p></div></div></div><div id="slide-number" class="slide-number">
         1
      </div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/gotoSlide.js"></script><script type="text/javascript" src="js/hovercraft.js"></script><script type="text/javascript" src="talk.js"></script><script type="text/javascript" src="alectryon.js"></script><script type="text/javascript">
      document.getElementById("impress").addEventListener("impress:stepenter", update_slide_number, false);
    </script></body></html>